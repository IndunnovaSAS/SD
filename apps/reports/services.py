"""
Business logic services for reports and analytics.
"""

import logging
from datetime import date, datetime, timedelta

from django.db import transaction
from django.db.models import Avg, Count, Q
from django.utils import timezone

from apps.reports.models import (
    Dashboard,
    GeneratedReport,
    ReportTemplate,
    ScheduledReport,
    UserDashboard,
)

logger = logging.getLogger(__name__)


class ReportService:
    """Service for report generation operations."""

    @staticmethod
    @transaction.atomic
    def create_report_request(
        template: ReportTemplate,
        user,
        format_type: str = None,
        filters: dict = None,
    ) -> GeneratedReport:
        """
        Create a new report generation request.
        """
        report = GeneratedReport.objects.create(
            template=template,
            name=f"{template.name} - {timezone.now().strftime('%Y-%m-%d %H:%M')}",
            format=format_type or template.default_format,
            status=GeneratedReport.Status.PENDING,
            filters_applied=filters or {},
            generated_by=user,
            expires_at=timezone.now() + timedelta(days=7),
        )

        logger.info(f"Report request created: {report.id}")
        return report

    @staticmethod
    @transaction.atomic
    def start_generation(report: GeneratedReport) -> GeneratedReport:
        """
        Mark report as generating.
        """
        report.status = GeneratedReport.Status.GENERATING
        report.generation_started_at = timezone.now()
        report.save()

        return report

    @staticmethod
    @transaction.atomic
    def complete_generation(
        report: GeneratedReport,
        file_content: bytes,
        row_count: int = 0,
    ) -> GeneratedReport:
        """
        Complete report generation and save file.
        """
        from django.core.files.base import ContentFile

        # Determine file extension
        ext_map = {
            ReportTemplate.Format.PDF: "pdf",
            ReportTemplate.Format.EXCEL: "xlsx",
            ReportTemplate.Format.CSV: "csv",
            ReportTemplate.Format.HTML: "html",
        }
        ext = ext_map.get(report.format, "dat")

        # Save file
        filename = f"report_{report.id}.{ext}"
        report.file.save(filename, ContentFile(file_content), save=False)

        report.status = GeneratedReport.Status.COMPLETED
        report.generation_completed_at = timezone.now()
        report.file_size = len(file_content)
        report.row_count = row_count
        report.save()

        logger.info(f"Report completed: {report.id}, size: {report.file_size}")
        return report

    @staticmethod
    def fail_generation(
        report: GeneratedReport,
        error_message: str,
    ) -> GeneratedReport:
        """
        Mark report generation as failed.
        """
        report.status = GeneratedReport.Status.FAILED
        report.error_message = error_message
        report.generation_completed_at = timezone.now()
        report.save()

        logger.error(f"Report failed: {report.id}, error: {error_message}")
        return report

    @staticmethod
    def get_user_reports(user, limit: int = 50):
        """
        Get reports generated by a user.
        """
        return (
            GeneratedReport.objects.filter(generated_by=user)
            .select_related("template")
            .order_by("-created_at")[:limit]
        )

    @staticmethod
    def cleanup_expired_reports():
        """
        Delete expired reports.
        """
        expired = GeneratedReport.objects.filter(expires_at__lt=timezone.now())

        count = 0
        for report in expired:
            if report.file:
                report.file.delete(save=False)
            report.delete()
            count += 1

        if count > 0:
            logger.info(f"Deleted {count} expired reports")

        return count


class ScheduledReportService:
    """Service for scheduled report operations."""

    @staticmethod
    @transaction.atomic
    def create_schedule(
        template: ReportTemplate,
        name: str,
        frequency: str,
        format_type: str,
        time_of_day,
        user,
        filters: dict = None,
        recipients: list = None,
        day_of_week: int = None,
        day_of_month: int = None,
    ) -> ScheduledReport:
        """
        Create a new scheduled report.
        """
        schedule = ScheduledReport.objects.create(
            template=template,
            name=name,
            frequency=frequency,
            format=format_type,
            filters=filters or {},
            recipients=recipients or [],
            day_of_week=day_of_week,
            day_of_month=day_of_month,
            time_of_day=time_of_day,
            is_active=True,
            created_by=user,
        )

        # Calculate next run
        ScheduledReportService._calculate_next_run(schedule)

        return schedule

    @staticmethod
    def _calculate_next_run(schedule: ScheduledReport) -> None:
        """
        Calculate the next run time for a scheduled report.
        """
        now = timezone.now()
        today = now.date()

        # Base time for today
        next_run = timezone.make_aware(datetime.combine(today, schedule.time_of_day))

        if schedule.frequency == ScheduledReport.Frequency.DAILY:
            if next_run <= now:
                next_run += timedelta(days=1)

        elif schedule.frequency == ScheduledReport.Frequency.WEEKLY:
            if schedule.day_of_week is not None:
                days_ahead = schedule.day_of_week - today.weekday()
                if days_ahead <= 0:
                    days_ahead += 7
                next_run += timedelta(days=days_ahead)

        elif schedule.frequency == ScheduledReport.Frequency.BIWEEKLY:
            if schedule.day_of_week is not None:
                days_ahead = schedule.day_of_week - today.weekday()
                if days_ahead <= 0:
                    days_ahead += 14
                next_run += timedelta(days=days_ahead)

        elif schedule.frequency == ScheduledReport.Frequency.MONTHLY:
            if schedule.day_of_month is not None:
                next_month = today.replace(day=1) + timedelta(days=32)
                next_run = timezone.make_aware(
                    datetime.combine(
                        next_month.replace(day=min(schedule.day_of_month, 28)),
                        schedule.time_of_day,
                    )
                )

        schedule.next_run_at = next_run
        schedule.save()

    @staticmethod
    def get_due_schedules():
        """
        Get schedules that are due to run.
        """
        return ScheduledReport.objects.filter(
            is_active=True,
            next_run_at__lte=timezone.now(),
        ).select_related("template")

    @staticmethod
    @transaction.atomic
    def run_schedule(schedule: ScheduledReport) -> GeneratedReport:
        """
        Run a scheduled report.
        """
        # Create report request
        report = ReportService.create_report_request(
            template=schedule.template,
            user=schedule.created_by,
            format_type=schedule.format,
            filters=schedule.filters,
        )

        # Update schedule
        schedule.last_run_at = timezone.now()
        ScheduledReportService._calculate_next_run(schedule)

        logger.info(f"Scheduled report {schedule.id} executed, report: {report.id}")
        return report

    @staticmethod
    def toggle_schedule(schedule: ScheduledReport) -> ScheduledReport:
        """
        Toggle schedule active status.
        """
        schedule.is_active = not schedule.is_active
        if schedule.is_active:
            ScheduledReportService._calculate_next_run(schedule)
        schedule.save()

        return schedule


class DashboardService:
    """Service for dashboard operations."""

    @staticmethod
    def get_user_dashboard(user) -> dict:
        """
        Get dashboard data for a user.
        """
        # Get user's dashboard preference or default
        try:
            user_pref = user.dashboard_preference
            dashboard = user_pref.dashboard
        except UserDashboard.DoesNotExist:
            dashboard = Dashboard.objects.filter(is_default=True, is_active=True).first()

        widgets_data = {}
        if dashboard:
            for widget in dashboard.widgets:
                widget_type = widget.get("type")
                if widget_type:
                    data = DashboardService._get_widget_data(widget_type, user)
                    widgets_data[widget.get("id", widget_type)] = data

        return {
            "dashboard": dashboard,
            "widgets": widgets_data,
        }

    @staticmethod
    def _get_widget_data(widget_type: str, user) -> dict:
        """
        Get data for a specific widget type.
        """
        if widget_type == "training_progress":
            return DashboardService.get_training_progress(user)
        elif widget_type == "compliance_summary":
            return DashboardService.get_compliance_summary()
        elif widget_type == "recent_certifications":
            return DashboardService.get_recent_certifications()
        elif widget_type == "upcoming_deadlines":
            return DashboardService.get_upcoming_deadlines(user)
        elif widget_type == "assessment_stats":
            return DashboardService.get_assessment_stats()
        else:
            return {}

    @staticmethod
    def get_training_progress(user) -> dict:
        """
        Get training progress for a user.
        """
        from apps.courses.models import Enrollment

        enrollments = Enrollment.objects.filter(user=user)

        total = enrollments.count()
        completed = enrollments.filter(status=Enrollment.Status.COMPLETED).count()
        in_progress = enrollments.filter(status=Enrollment.Status.IN_PROGRESS).count()

        return {
            "total_courses": total,
            "completed": completed,
            "in_progress": in_progress,
            "completion_rate": (completed / total * 100) if total > 0 else 0,
        }

    @staticmethod
    def get_compliance_summary() -> dict:
        """
        Get organization-wide compliance summary.
        """
        from apps.courses.models import Enrollment

        enrollments = Enrollment.objects.all()
        total = enrollments.count()
        completed = enrollments.filter(status=Enrollment.Status.COMPLETED).count()
        expired = enrollments.filter(status=Enrollment.Status.EXPIRED).count()

        return {
            "total_enrollments": total,
            "completed": completed,
            "expired": expired,
            "compliance_rate": (completed / total * 100) if total > 0 else 0,
        }

    @staticmethod
    def get_recent_certifications(limit: int = 10) -> list:
        """
        Get recent certifications issued.
        """
        from apps.certifications.models import Certificate

        certs = (
            Certificate.objects.filter(status=Certificate.Status.ISSUED)
            .select_related("user", "course")
            .order_by("-issued_at")[:limit]
        )

        return [
            {
                "id": cert.id,
                "user_name": cert.user.get_full_name(),
                "course_title": cert.course.title,
                "issued_at": cert.issued_at.isoformat() if cert.issued_at else None,
            }
            for cert in certs
        ]

    @staticmethod
    def get_upcoming_deadlines(user, days_ahead: int = 30) -> list:
        """
        Get upcoming training deadlines for a user.
        """
        from apps.learning_paths.models import PathAssignment

        deadline = timezone.now().date() + timedelta(days=days_ahead)

        assignments = (
            PathAssignment.objects.filter(
                user=user,
                due_date__lte=deadline,
                status__in=[
                    PathAssignment.Status.ASSIGNED,
                    PathAssignment.Status.IN_PROGRESS,
                ],
            )
            .select_related("learning_path")
            .order_by("due_date")[:10]
        )

        return [
            {
                "id": a.id,
                "path_name": a.learning_path.name,
                "due_date": a.due_date.isoformat() if a.due_date else None,
                "progress": a.progress,
            }
            for a in assignments
        ]

    @staticmethod
    def get_assessment_stats() -> dict:
        """
        Get assessment statistics.
        """
        from apps.assessments.models import AssessmentAttempt

        attempts = AssessmentAttempt.objects.filter(status=AssessmentAttempt.Status.GRADED)

        total = attempts.count()
        passed = attempts.filter(passed=True).count()

        stats = attempts.aggregate(
            avg_score=Avg("score"),
        )

        return {
            "total_attempts": total,
            "passed": passed,
            "pass_rate": (passed / total * 100) if total > 0 else 0,
            "average_score": float(stats["avg_score"] or 0),
        }

    @staticmethod
    @transaction.atomic
    def set_user_dashboard(user, dashboard: Dashboard) -> UserDashboard:
        """
        Set a user's dashboard preference.
        """
        user_dashboard, _ = UserDashboard.objects.update_or_create(
            user=user,
            defaults={"dashboard": dashboard},
        )

        return user_dashboard


class AnalyticsService:
    """Service for analytics and reporting data."""

    @staticmethod
    def get_training_report(
        start_date: date = None,
        end_date: date = None,
        contract_id: int = None,
    ) -> dict:
        """
        Get comprehensive training report data.
        """
        from apps.courses.models import Enrollment

        enrollments = Enrollment.objects.all()

        if start_date:
            enrollments = enrollments.filter(created_at__date__gte=start_date)
        if end_date:
            enrollments = enrollments.filter(created_at__date__lte=end_date)

        # By status
        by_status = enrollments.values("status").annotate(count=Count("id"))

        # By course
        by_course = (
            enrollments.values("course__title", "course__code")
            .annotate(
                enrolled=Count("id"),
                completed=Count("id", filter=Q(status=Enrollment.Status.COMPLETED)),
            )
            .order_by("-enrolled")[:20]
        )

        # Completion trend (by week)
        from django.db.models.functions import TruncWeek

        completion_trend = (
            enrollments.filter(status=Enrollment.Status.COMPLETED)
            .annotate(week=TruncWeek("completed_at"))
            .values("week")
            .annotate(count=Count("id"))
            .order_by("week")[-12:]
        )

        return {
            "total_enrollments": enrollments.count(),
            "by_status": {item["status"]: item["count"] for item in by_status},
            "by_course": list(by_course),
            "completion_trend": [
                {"week": item["week"].isoformat() if item["week"] else None, "count": item["count"]}
                for item in completion_trend
            ],
        }

    @staticmethod
    def get_compliance_report(
        start_date: date = None,
        end_date: date = None,
    ) -> dict:
        """
        Get compliance report data.
        """
        from apps.certifications.models import Certificate

        # Expired certifications
        expired_certs = Certificate.objects.filter(status=Certificate.Status.EXPIRED).count()

        # Expiring soon (next 30 days)
        expiring_soon = Certificate.objects.filter(
            status=Certificate.Status.ISSUED,
            expires_at__lte=timezone.now() + timedelta(days=30),
            expires_at__gt=timezone.now(),
        ).count()

        # Overdue training
        from apps.learning_paths.models import PathAssignment

        overdue = PathAssignment.objects.filter(
            due_date__lt=timezone.now().date(),
            status__in=[
                PathAssignment.Status.ASSIGNED,
                PathAssignment.Status.IN_PROGRESS,
            ],
        ).count()

        # Active valid certifications
        valid_certs = Certificate.objects.filter(status=Certificate.Status.ISSUED).count()

        return {
            "valid_certifications": valid_certs,
            "expired_certifications": expired_certs,
            "expiring_soon": expiring_soon,
            "overdue_assignments": overdue,
            "compliance_score": AnalyticsService._calculate_compliance_score(),
        }

    @staticmethod
    def _calculate_compliance_score() -> float:
        """
        Calculate overall compliance score.
        """
        from apps.courses.models import Course, Enrollment

        # Get mandatory courses
        mandatory_courses = Course.objects.filter(
            course_type=Course.Type.MANDATORY,
            status=Course.Status.PUBLISHED,
        )

        if not mandatory_courses.exists():
            return 100.0

        # Count completed enrollments for mandatory courses
        total_required = 0
        total_completed = 0

        from apps.accounts.models import User

        active_users = User.objects.filter(is_active=True).count()

        for course in mandatory_courses:
            total_required += active_users
            completed = Enrollment.objects.filter(
                course=course,
                status=Enrollment.Status.COMPLETED,
            ).count()
            total_completed += completed

        if total_required == 0:
            return 100.0

        return (total_completed / total_required) * 100

    @staticmethod
    def get_assessment_report(
        start_date: date = None,
        end_date: date = None,
    ) -> dict:
        """
        Get assessment report data.
        """
        from apps.assessments.models import AssessmentAttempt

        attempts = AssessmentAttempt.objects.filter(status=AssessmentAttempt.Status.GRADED)

        if start_date:
            attempts = attempts.filter(started_at__date__gte=start_date)
        if end_date:
            attempts = attempts.filter(started_at__date__lte=end_date)

        # By assessment
        by_assessment = (
            attempts.values("assessment__title")
            .annotate(
                total=Count("id"),
                passed=Count("id", filter=Q(passed=True)),
                avg_score=Avg("score"),
            )
            .order_by("-total")[:20]
        )

        # Overall stats
        total = attempts.count()
        passed = attempts.filter(passed=True).count()

        return {
            "total_attempts": total,
            "passed": passed,
            "failed": total - passed,
            "pass_rate": (passed / total * 100) if total > 0 else 0,
            "by_assessment": list(by_assessment),
        }

    @staticmethod
    def get_user_training_history(user) -> dict:
        """
        Get complete training history for a user.
        """
        from apps.assessments.models import AssessmentAttempt
        from apps.certifications.models import Certificate
        from apps.courses.models import Enrollment

        # Enrollments
        enrollments = (
            Enrollment.objects.filter(user=user).select_related("course").order_by("-created_at")
        )

        # Attempts
        attempts = (
            AssessmentAttempt.objects.filter(user=user)
            .select_related("assessment")
            .order_by("-started_at")[:20]
        )

        # Certifications
        certificates = (
            Certificate.objects.filter(user=user).select_related("course").order_by("-issued_at")
        )

        return {
            "enrollments": [
                {
                    "course_title": e.course.title,
                    "status": e.status,
                    "progress": e.progress,
                    "created_at": e.created_at.isoformat(),
                    "completed_at": e.completed_at.isoformat() if e.completed_at else None,
                }
                for e in enrollments
            ],
            "recent_attempts": [
                {
                    "assessment_title": a.assessment.title,
                    "score": float(a.score) if a.score else 0,
                    "passed": a.passed,
                    "date": a.started_at.isoformat(),
                }
                for a in attempts
            ],
            "certificates": [
                {
                    "course_title": c.course.title,
                    "certificate_number": c.certificate_number,
                    "status": c.status,
                    "issued_at": c.issued_at.isoformat() if c.issued_at else None,
                    "expires_at": c.expires_at.isoformat() if c.expires_at else None,
                }
                for c in certificates
            ],
        }
